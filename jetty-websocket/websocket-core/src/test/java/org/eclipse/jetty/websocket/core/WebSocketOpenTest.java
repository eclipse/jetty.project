//
//  ========================================================================
//  Copyright (c) 1995-2019 Mort Bay Consulting Pty. Ltd.
//  ------------------------------------------------------------------------
//  All rights reserved. This program and the accompanying materials
//  are made available under the terms of the Eclipse Public License v1.0
//  and Apache License v2.0 which accompanies this distribution.
//
//      The Eclipse Public License is available at
//      http://www.eclipse.org/legal/epl-v10.html
//
//      The Apache License v2.0 is available at
//      http://www.opensource.org/licenses/apache2.0.php
//
//  You may elect to redistribute this code under either of these licenses.
//  ========================================================================
//

package org.eclipse.jetty.websocket.core;

import java.net.Socket;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Exchanger;
import java.util.concurrent.TimeUnit;
import java.util.function.BiFunction;

import org.eclipse.jetty.util.BufferUtil;
import org.eclipse.jetty.util.Callback;
import org.eclipse.jetty.util.log.Log;
import org.eclipse.jetty.util.log.Logger;
import org.eclipse.jetty.util.log.StacklessLogging;
import org.eclipse.jetty.websocket.core.internal.Parser;
import org.eclipse.jetty.websocket.core.internal.WebSocketCoreSession;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;

import static org.eclipse.jetty.util.Callback.NOOP;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.notNullValue;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Tests of a core server with a fake client
 */
public class WebSocketOpenTest extends WebSocketTester
{
    private static Logger LOG = Log.getLogger(WebSocketOpenTest.class);

    private WebSocketServer server;
    private TestFrameHandler serverHandler;
    private Socket client;

    @AfterEach
    public void after() throws Exception
    {
        if (server != null)
            server.stop();
    }

    public void setup(BiFunction<FrameHandler.CoreSession, Callback, Void> onOpen) throws Exception
    {
        serverHandler = new TestFrameHandler(onOpen);
        server = new WebSocketServer(serverHandler);
        server.start();
        client = newClient(server.getLocalPort());
    }

    @Test
    public void testSendFrameInOnOpen() throws Exception
    {
        setup((s, c) ->
        {
            assertThat(s.toString(), containsString("CONNECTED"));
            WebSocketOpenTest.TestFrameHandler.sendText(s, "Hello", Callback.NOOP);
            c.succeeded();
            s.demand(1);
            return null;
        });
        Parser.ParsedFrame frame = receiveFrame(client.getInputStream());
        assertThat(frame.getPayloadAsUTF8(), is("Hello"));

        client.getOutputStream().write(RawFrameBuilder.buildClose(new CloseStatus(CloseStatus.NORMAL), true));
        assertTrue(serverHandler.onClosed.await(5, TimeUnit.SECONDS));
        assertThat(serverHandler.closeStatus.getCode(), is(CloseStatus.NORMAL));

        frame = receiveFrame(client.getInputStream());
        assertThat(frame.getOpCode(), is(OpCode.CLOSE));
        assertThat(new CloseStatus(frame).getCode(), is(CloseStatus.NORMAL));
    }

    @Test
    public void testFailureInOnOpen() throws Exception
    {
        try (StacklessLogging stackless = new StacklessLogging(WebSocketCoreSession.class))
        {
            setup((s, c) ->
            {
                assertThat(s.toString(), containsString("CONNECTED"));
                c.failed(new Exception("Test Exception in onOpen"));
                return null;
            });

            assertTrue(serverHandler.onError.await(5, TimeUnit.SECONDS));
            assertThat(serverHandler.error, notNullValue());

            assertTrue(serverHandler.onClosed.await(5, TimeUnit.SECONDS));
            assertThat(serverHandler.closeStatus.getCode(), is(CloseStatus.SERVER_ERROR));

            Parser.ParsedFrame frame = receiveFrame(client.getInputStream());
            assertThat(frame.getOpCode(), is(OpCode.CLOSE));
            assertThat(new CloseStatus(frame).getCode(), is(CloseStatus.SERVER_ERROR));
        }
    }

    @Test
    public void testCloseInOnOpen() throws Exception
    {
        setup((s, c) ->
        {
            assertThat(s.toString(), containsString("CONNECTED"));
            s.close(CloseStatus.SHUTDOWN, "Test close in onOpen", c);
            return null;
        });

        Parser.ParsedFrame frame = receiveFrame(client.getInputStream());
        assertThat(frame.getOpCode(), is(OpCode.CLOSE));
        assertThat(new CloseStatus(frame).getCode(), is(CloseStatus.SHUTDOWN));

        client.getOutputStream().write(RawFrameBuilder.buildClose(new CloseStatus(CloseStatus.NORMAL), true));
        assertTrue(serverHandler.onClosed.await(5, TimeUnit.SECONDS));
        assertThat(serverHandler.closeStatus.getCode(), is(CloseStatus.SHUTDOWN));
    }

    @Test
    public void testAsyncOnOpen() throws Exception
    {
        Exchanger<FrameHandler.CoreSession> sx = new Exchanger<>();
        Exchanger<Callback> cx = new Exchanger<>();
        setup((s, c) ->
        {
            assertThat(s.toString(), containsString("CONNECTED"));
            try
            {
                sx.exchange(s);
                cx.exchange(c);
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException(e);
            }
            return null;
        });

        FrameHandler.CoreSession coreSession = sx.exchange(null);
        Callback onOpenCallback = cx.exchange(null);
        Thread.sleep(100);

        // Can send while onOpen is active
        WebSocketOpenTest.TestFrameHandler.sendText(coreSession, "Hello", NOOP);
        Parser.ParsedFrame frame = receiveFrame(client.getInputStream());
        assertThat(frame.getPayloadAsUTF8(), is("Hello"));

        // But cannot receive
        client.getOutputStream().write(RawFrameBuilder.buildClose(new CloseStatus(CloseStatus.NORMAL), true));
        assertFalse(serverHandler.onClosed.await(1, TimeUnit.SECONDS));

        // Can't demand until open
        assertThrows(Throwable.class, () -> coreSession.demand(1));
        client.getOutputStream().write(RawFrameBuilder.buildClose(new CloseStatus(CloseStatus.NORMAL), true));
        assertFalse(serverHandler.onClosed.await(1, TimeUnit.SECONDS));

        // Succeeded moves to OPEN state and still does not read CLOSE frame
        onOpenCallback.succeeded();
        assertThat(coreSession.toString(), containsString("OPEN"));

        // Demand start receiving frames
        coreSession.demand(1);
        client.getOutputStream().write(RawFrameBuilder.buildClose(new CloseStatus(CloseStatus.NORMAL), true));
        assertTrue(serverHandler.onClosed.await(5, TimeUnit.SECONDS));

        // Closed handled normally
        assertTrue(serverHandler.onClosed.await(5, TimeUnit.SECONDS));
        assertThat(serverHandler.closeStatus.getCode(), is(CloseStatus.NORMAL));
        frame = receiveFrame(client.getInputStream());
        assertThat(frame.getOpCode(), is(OpCode.CLOSE));
        assertThat(new CloseStatus(frame).getCode(), is(CloseStatus.NORMAL));
    }

    static class TestFrameHandler implements SynchronousFrameHandler
    {
        private CoreSession coreSession;
        private BiFunction<CoreSession, Callback, Void> onOpen;
        private CloseStatus closeStatus;
        private CountDownLatch onClosed = new CountDownLatch(1);
        private Throwable error;
        private CountDownLatch onError = new CountDownLatch(1);
        private Frame frame;
        private CountDownLatch onFrame = new CountDownLatch(1);

        public CoreSession getCoreSession()
        {
            synchronized (this)
            {
                return coreSession;
            }
        }

        TestFrameHandler(BiFunction<CoreSession, Callback, Void> onOpen)
        {
            this.onOpen = onOpen;
        }

        @Override
        public void onOpen(CoreSession coreSession, Callback callback)
        {
            LOG.info("onOpen {}", coreSession);
            synchronized (this)
            {
                this.coreSession = coreSession;
            }
            onOpen.apply(coreSession, callback);
        }

        @Override
        public void onFrame(Frame frame, Callback callback)
        {
            LOG.info("onFrame: " + BufferUtil.toDetailString(frame.getPayload()));
            callback.succeeded();
            if (onFrame.getCount() == 1)
            {
                this.frame = frame;
                onFrame.countDown();
            }
        }

        @Override
        public void onError(Throwable cause)
        {
            LOG.info("onError {} ", cause == null ? null : cause.toString());
            if (onError.getCount() != 1)
                throw new IllegalStateException();
            error = cause;
            onError.countDown();
        }

        @Override
        public void onClosed(CloseStatus closeStatus)
        {
            LOG.info("onClosed {}", closeStatus);
            if (onClosed.getCount() != 1)
                throw new IllegalStateException();
            this.closeStatus = closeStatus;
            onClosed.countDown();
        }

        @Override
        public boolean isDemanding()
        {
            return true;
        }

        public void sendText(String text)
        {
            sendText(coreSession, text);
        }

        public void sendText(String text, Callback callback)
        {
            sendText(coreSession, text, callback);
        }

        static void sendText(FrameHandler.CoreSession coreSession, String text)
        {
            sendText(coreSession, text, NOOP);
        }

        static void sendText(FrameHandler.CoreSession coreSession, String text, Callback callback)
        {
            Frame frame = new Frame(OpCode.TEXT);
            frame.setFin(true);
            frame.setPayload(text);

            coreSession.sendFrame(frame, callback, false);
        }
    }
}
