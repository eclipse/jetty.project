//
// ========================================================================
// Copyright (c) 1995-2021 Mort Bay Consulting Pty Ltd and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
// ========================================================================
//

[[pg-server-websocket]]
=== WebSocket Server

// JettyWebSocketServletContainerInitializer.configure(ServletContextHandler context, Configurator configurator); is one entry point.

// JettyWebSocketServlet.configure(JettyWebSocketServletFactory factory); another entry point.

// TODO: why they expose different interfaces? Configurator exposes JettyWebSocketServerContainer, the servlet exposes JettyWebSocketServletFactory => historical, live with it.

// WSUFilter is automatically added lazily when context is started or when calling addMapping().
// Talk about WSUF but in the context of the upgrade, not much as an API to use, only init-params.
// WSUF init-params will however configure both Jetty and Javax containers.
// WSUF has a specific name in web.xml if you want to provide a WSUF that has a different config, e.g. different mapping than /*, or different init-params.

// For Javax I can pass in an HttpClient via ServletContext attribute.
// Also describe the XML file for HttpClient => needed to avoid class loader issues?

// WSUF and Servlet are typically mutually exclusive.
// However, WSUF could be mapped to /foo and servlet to /bar; OR
// WSUF has a mapping for /ep1 and Servlet has a mapping for /ep2, so an upgrade request enters WSUF, finds no mapping, forwards, lands to Servlet where the mapping is found.

Jetty provides two API implementations of the WebSocket protocol:

* An implementation for the standard `javax.websocket` APIs provided by link:https://www.jcp.org/en/jsr/detail?id=356[JSR 356], described in xref:pg-server-websocket-javax[this section].
* An implementation for Jetty-specific WebSocket APIs, described in xref:pg-server-websocket-jetty[this section].

Using the standard `javax.websocket` APIs allows your applications to depend only on standard APIs, and your applications may be deployed in any compliant WebSocket Container that supports JSR 356.

The standard APIs provide few features that are not present in the Jetty WebSocket APIs:

* Encoders and Decoders for automatic conversion of text or binary messages to objects.
* `Reader` and `InputStream` for simple, blocking, message streaming.
* Simple URI template matching.

On the other hand, the Jetty WebSocket APIs are more efficient and offer greater and more fine-grained control, and provide features that are not present in the standard APIs:

* `MessageSink` for advanced, asynchronous, message streaming with backpressure.
* Suspend/resume to control backpressure.
* Remote socket address (IP address and port) information.
* WebSocket upgrade handling via Filter or Servlet.
* Advanced URI matching with Servlet WebSocket upgrade.
* Control of the idle timeout.
* Configuration of the network buffer capacity.

If your application needs specific features that are not provided by the standard APIs, the Jetty WebSocket APIs may provide such features -- and if they do not, you may ask for these features by submitting an issue to the Jetty Project without waiting for the standard process to approve them.

include::server-websocket-standard.adoc[]
include::server-websocket-jetty.adoc[]
